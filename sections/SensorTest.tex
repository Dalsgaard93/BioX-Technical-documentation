\chapter{Test of IMU's}\label{ch:ST}

The IMU's used in this project are initially subjected to a linearity test to determine the accuracy. This is performed using an industrial milling-machine in which the IMU's are spinned around to apply centrifugal acceleration. This setup is re-created as a 3D model in AMS, which acts as the Gold standard.

\section{Experiment setup}

Initially, an experimental protocol is developed and tested to test the accuracy of each IMU and to ensure that the transformations of accelerations are done correctly in the AnyBody Modelling System (AMS). The setup contains the use of a milling machine with an industrial accurate controllable velocity. A simple model of the milling machine is modelled in the AMS. Prior to the industrial milling machine test, a custom made mount is designed using SolidWorks, see technical drawing in figure \ref{fig:mount}. The milling machine mount is saved as a STL-file and 3D printet in Polylactide (PLA) material. The Polar IMU is securely attached to the milling machine, see fig \ref{fig:mil:emptymount}, \ref{fig:mil:mountsensorclose}, \ref{fig:mil:mountmachine}. This setup allows investigation of the centrifugal acceleration acting on the Polar IMU at different velocities of the industrial milling machine, see figure \ref{fig:Setup}. Data from the Polar IMU, mathematical calculations and data from the AMS are used for comparison and evaluation of the local accelerations \newline 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.95\linewidth]{Photos/mount.PNG}
    \caption{Technical drawing of milling machine mount}
    \label{fig:mount}
\end{figure}
\newpage

% Setup pictures
\subsection{Pictures of setup}
Presented below is pictures of the experimental setup, including the mount, placement of IMU and the full assembly.

    \vspace{1cm}
    % Empty mount
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/Milling/Setup/EmptyCloseSide.jpg}
        \caption{Milling machine mount without IMU attached.}
        \label{fig:mil:emptymount}
    \end{figure}
    
    \vspace{1cm}
    
    % Sensor in mount
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/Milling/Setup/OneSideClose.jpg}
        \caption{Close-up of one of the IMUs placed in the mount.}
        \label{fig:mil:mountsensorclose}
    \end{figure}
    
    \vspace{1cm}
    
    % Mount in milling machine
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/Milling/Setup/MachineSetup.jpg}
        \caption{Mounts attached in milling machine.}
        \label{fig:mil:mountmachine}
    \end{figure}
    \newpage

\section{Experimental protocol}
This section describes the experimental protocol of the IMU test. \\

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\linewidth]{Photos/setup_v3.png}
    \caption{Illustration of experimental setup with one Polar IMU attached to a milling machine}
    \label{fig:Setup}
\end{figure}


\begin{enumerate}
\setlength\itemsep{0em}
    \item Check Polar IMU
        \begin{itemize}\vspace{-.3cm}
        \setlength\itemsep{0em}
            \item Green signal if battery is ok, if yellow/red - change the battery
            \item Connect to Polar data download and delete file list
        \end{itemize}
    
    \item Check if the coordinate system of the setup correspond to drawings
    \item Mount Polar IMU
        \begin{itemize}\vspace{-.3cm}
        \setlength\itemsep{0em}
            \item Check green light for data collection (blink each 5 sec.)
        \end{itemize}
    \item Fit the mount to the milling machine, including IMUs     
    \item Test of IMUs(30 seconds for each speed):
    
% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[h]
  \centering
  \caption{Test speeds}
    \begin{tabular}{ccc}
    \textbf{G-force} & \textbf{ RPM} & \textbf{Rnd RPM} \\
    \midrule
    1     & 67.22 & 67 \\
    2     & 95.06 & 95 \\
    3     & 116.42 & 116 \\
    4     & 134.43 & 134 \\
    5     & 150.30 & 150 \\
    6     & 164.65 & 165 \\
    7     & 177.84 & 178 \\
    8     & 190.12 & 190 \\
    9     & 201.65 & 202 \\
    10    & 212.56 & 213 \\
    11    & 222.93 & 223 \\
    12    & 232.84 & 233 \\
    13    & 242.35 & 242 \\
    14    & 251.50 & 251 \\
    15    & 260.33 & 260 \\
    16    & 268.86 & 269 \\
    \bottomrule
    \end{tabular}%
  \label{tab:addlabel}%
\end{table}%


    \item Dismount the Polar IMU from the Polar strap and connect to computer
    \item Check data
        \begin{itemize}\vspace{-.3cm}
        \setlength\itemsep{0em}
            \item Did the Polar IMU actually collect data?
            \item Get file list and download test data
            \item Is it possible to distinguish between the different speeds/accelerations?
        \end{itemize}

\end{enumerate}


\newpage
\section{AnyBody model of milling machine}
    A simple AnyBody model is created in the AMS to provide point accelerations corresponding to the Polar IMU. The arm of the milling machine is modelled as a rigid segment attached to a fixed point/node, in which the rotation is centred around. The speed of the milling machine is controllable and defined in Velocity.any as (degrees/s)*pi/180. \\
    
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/Milling/Setup/ABmodel.PNG}
        \caption{Illustration of the simple AMS model representing the milling machine setup.}
        \label{fig:my_label}
    \end{figure}
    
    \subsection{Local accelerations in the AnyBody Modeling System}

        To provide local accelerations from global accelerations in the AMS, some calculations are necessary. In the AMS, local accelerations are created as a$_-$prime:
        %\vspace{.5cm}
        
        \begin{center}
           Gravitational acceleration (g) = $9.81$ $m/s^2$ 
        \end{center}
        
        \begin{equation} \label{Cen_Acc}
            Centrifugal_{Acc} = \frac{V^2}{r}
        \end{equation}
        
        where V = velocity of the milling machine, r = radius from the IMU to the center of rotation on the milling machine. 
        
        \begin{equation}
            a' = \begin{pmatrix}
                v^2/r \\
                $0$
                \end{pmatrix}+g'
        \end{equation}
        
        \begin{equation}
              = \begin{pmatrix}
                v^2/r \\
                $0$
                \end{pmatrix}+Ag
        \end{equation}
        
        \begin{equation}
            = \begin{pmatrix}
                v^2/r \\
                $0$
                \end{pmatrix}
                +
                \begin{bmatrix} 
                 Cos\theta & - & Sin\theta \\
                 Sin \theta & & Cos \theta 
            \end{bmatrix}
            *
            \begin{pmatrix}
                $0$ \\
                $g$ 
            \end{pmatrix}
        \end{equation}
        
        
        \begin{equation}
            \newcommand\transp{^\intercal\kern-\scriptspace}
            \Vec{\textbf{r}}' = 
             (\mathbf{A}\transp \Vec{\textbf{r}}\transp)\transp + (\mathbf{A}\transp \Vec{\textbf{g}}\transp)\transp
        \end{equation}
\newcommand\transp{^\intercal\kern-\scriptspace}
where $\Vec{\textbf{r}}'$ = local acceleration, $\mathbf{A}\transp$ = transposed rotation matrix, $\Vec{\textbf{r}}\transp$ = transposed global point acceleration, $\Vec{\textbf{g}}\transp$ = transposed gravitational acceleration.  
    
    \subsection{Mathematical sanity-check}
    
        To ensure that the milling machine setup in the AMS provides accurate accelerations, calculations are done in four different angles at each speed as a sanity-check. The calculations are done by calculating the centrifugal accelerations and adding the gravitational acceleration, corresponding to: \newline
        
        \begin{equation} \label{0}
            a'_{0\degree} = Centrifugal_{Acc}+(-9.81,0)
        \end{equation}
        
        \begin{equation} \label{0}
            a'_{90\degree} = Centrifugal_{Acc}+(0,9.81)
        \end{equation}
        
        \begin{equation} \label{0}
            a'_{180\degree} = Centrifugal_{Acc}+(9.81,0)
        \end{equation}
        
        \begin{equation} \label{0}
            a'_{270\degree} = Centrifugal_{Acc}+(0,-9.81)
        \end{equation}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{Photos/first.png}
    \caption{Illustration of 0 and 180 degrees setup in the sanity-check.}
    \label{fig:my_label}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Photos/second.png}
    \caption{Illustration of 90 and 270 degrees setup in the sanity-check.}
    \label{fig:my_label}
\end{figure}
\newpage


\section{Code}
\subsection{AMS}
\begin{lstlisting}[language=C++]
// Milling machine AnyBody model

Main = {

// AccModel
AnyFolder AccModel = {

// Global Reference Frame
AnyFixedRefFrame GlobalRef = {
  AnyDrawRefFrame DrwGlobalRef = {
    ScaleXYZ = {0.1, 0.1, 0.1};
    RGB = {0,1,0};
  };
  
  AnyRefNode Contact = {
    sRel = {0,0,0};
  };     
};  // Global reference frame

// Segments
AnyFolder Segs = {
  
  AnySeg Fitting = 
  {
    Axes0 = RotMat(-90*pi/180, z);
    Mass = 2.0;
    Jii = {0.001, 0.01, 0.01};
    AnyDrawSeg drw = {};
    
    AnyRefNode ContactNode = {
      sRel = {0,0,0};
    };
    AnyRefNode AccNode = {
      sRel = {0.198,0,0};
      AnyDrawRefFrame DrwAccRef = {
        ScaleXYZ = {0.1, 0.1, 0.1};
        RGB = {0,1,0};
      };      
    };
  }; 
}; // Segs folder

AnyFolder Jnts = {
  
  AnyRevoluteJoint Contact = {
    
    AnyRefNode &GroundNode = ..GlobalRef.Contact;
    AnyRefNode &FittingNode = ..Segs.Fitting.ContactNode;
    Axis = z;    
  };
}; // Jnts folder

AnyFolder Drivers = {
  //---------------------------------
  AnyKinEqSimpleDriver Motion = {
    AnyRevoluteJoint &Jnt = ..Jnts.Contact;
    #include "Velocity.any"
    DriverPos = {90*pi/180};
  }; 
}; // Driver folder
}; // AccModel

// The study: Operations to be performed on the model
AnyBodyStudy AccStudy = {
AnyFolder &Model = .AccModel;
tStart = 0.0;
tEnd = 1;
#include "nStep.any"
Gravity = {0.0, -9.81, 0.0};
// Output
AnyVec3 a_prime = (Main.AccModel.Segs.Fitting.AccNode.Axes'*Main.AccModel.Segs.Fitting.AccNode.rDDot')'
+(Main.AccModel.Segs.Fitting.AccNode.Axes'*Gravity')';
AnyVec3 a = Main.AccModel.Segs.Fitting.AccNode.rDDot + Gravity;
}; 
};  // Main
\end{lstlisting}

\subsection{Python}

\subsubsection{Data import}
Import of sensor data to python. Also outputtet as .csv.
\begin{lstlisting}[language=Python]
import numpy as np
import pandas as pd
import scipy as sp
import time
from scipy import signal
import matplotlib.pyplot as plt
import json


def PolarImport(file, sensortype):
    """
    Imports and converts raw data from Polar sensor.
    'file' is expected to be .txt, where the top 9 rows will be discarded.
    'sensortype' should be "Acc" or "Gyr", depending on the device.
    """
    raw = np.loadtxt(file, delimiter=None, skiprows=9) 
    if sensortype == "Acc":
        raw[:, :3] /= 1000
        raw[:, :3] *= 9.81
        raw[:, 1] = -raw[:, 1]  # Adjust 'y' axis
        raw[:, 3] -= raw[0, 3]
        raw[:, 3] /= 32768
    if sensortype == "Gyr":
        raw[:, 1] = -raw[:, 1]  # Adjust 'y' axis
        raw[:, 3] -= raw[0, 3]
        raw[:, 3] /= 32768
    return raw

def cut_milling(data):
    plt.figure(num=None, figsize=(10, 8), dpi=100, facecolor='w', edgecolor='k' )
    plt.plot(data.values[:,0:3])
    plt.title("Please select the desired range")
    plt.xlabel("Frame (n)")
    plt.ylabel("Acceleration (m/s^2)") 
    ginput = plt.ginput(2, timeout=0)
    ginput = pd.DataFrame(ginput)
    StartRange = int(ginput.values[0, 0])
    EndRange = int(ginput.values[1, 0])
    windLength = round(data.values[EndRange, 3], 2) - round(data.values[StartRange, 3], 2)
    plt.close()
    dataWind = data[StartRange:EndRange]
    return dataWind
    
### Main   
inputPath = "C:/Users/raoul/Documents/Aalborg Universitet/Speciale/AnybodyPolar/pca-driven-model/Data/Data_milling_machine/SecondTestX4/Raw/"

outputRHfile = "dataRH.csv"
outputRTfile = "dataRT.csv"
outputLHfile = "dataLH.csv"
outputLTfile = "dataLT.csv"
outputLTfile = "dataSN.csv"

outputtxt = "test.txt"
json_path = r'C:\Users\raoul\Documents\Aalborg Universitet\Speciale\AnybodyPolar\pca-driven-model\Output\jsontest.json'

inputAccFix = "ACC.txt"
inputGyrFix = "GYRO.txt"

inputRHfile = "ECG_M_BS01v4RH_HW_4.0_BD_"  # RightHand
inputRTfile = "ECG_M_BS01v4RT_HW_4.0_BD_"  # RightTibia
inputLHfile = "ECG_M_BS01v4LH_HW_4.0_BD_"  # LeftHand
inputLTfile = "ECG_M_BS01v4LT_HW_4.0_BD_"  # LeftTibia
inputSNfile = "ECG_M_BS01v4SN_HW_4.0_BD_"  # Sternum

dataRHraw = pd.DataFrame(PolarImport(inputPath + inputRHfile + inputAccFix, "Acc"), columns=["AX", "AY", "AZ", "AT"])
dataRTraw = pd.DataFrame(PolarImport(inputPath + inputRTfile + inputAccFix, "Acc"), columns=["AX", "AY", "AZ", "AT"])
dataLHraw = pd.DataFrame(PolarImport(inputPath + inputLHfile + inputAccFix, "Acc"), columns=["AX", "AY", "AZ", "AT"])           
dataLTraw = pd.DataFrame(PolarImport(inputPath + inputLTfile + inputAccFix, "Acc"), columns=["AX", "AY", "AZ", "AT"])
dataSNraw = pd.DataFrame(PolarImport(inputPath + inputSNfile + inputAccFix, "Acc"), columns=["AX", "AY", "AZ", "AT"])

dataRHcut = pd.DataFrame(cut_milling(dataRHraw))
dataRTcut = pd.DataFrame(cut_milling(dataRTraw))
dataLHcut = pd.DataFrame(cut_milling(dataLHraw))  
dataLTcut = pd.DataFrame(cut_milling(dataLTraw))
dataSNcut = pd.DataFrame(cut_milling(dataSNraw))

dataRHcut.to_csv(inputPath+"dataRH.csv", index=None, sep=',', header=True)
dataRTcut.to_csv(inputPath+"dataRT.csv", index=None, sep=',', header=True)
dataLHcut.to_csv(inputPath+"dataLH.csv", index=None, sep=',', header=True)
dataLTcut.to_csv(inputPath+"dataLT.csv", index=None, sep=',', header=True)
dataSNcut.to_csv(inputPath+"dataSN.csv", index=None, sep=',', header=True)
\end{lstlisting}
\clearpage

\subsubsection{Data windowing}

\begin{lstlisting}[language=Python]
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import pickle

def cut_milling(data):
    plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k' )
    plt.plot(data.values[:,0:3])
    plt.title("Please select the desired range")
    plt.xlabel("Frame (n)")
    plt.ylabel("Acceleration (m/s^2)") 
    ginput = plt.ginput(2, timeout=0)
    ginput = pd.DataFrame(ginput)
    StartRange = int(ginput.values[0, 0])
    EndRange = int(ginput.values[1, 0])
    plt.close()
    dataWind = data[StartRange:EndRange]
    return dataWind

os.chdir("C:/Users/raoul/Documents/Aalborg Universitet/Speciale/AnybodyPolar"
         "/pca-driven-model/Data/Data_milling_machine/SecondTestX4/Raw/")

# Read data
SensorRH = pd.read_csv("dataRH.csv")
SensorRT = pd.read_csv("dataRT.csv")
SensorLH = pd.read_csv("dataLH.csv")
SensorLT = pd.read_csv("dataLT.csv")
SensorSN = pd.read_csv("dataSN.csv")

# Correct operational sign
SensorLH.values[:,0:3] = -SensorLH.values[:,0:3]
SensorLT.values[:,0:3] = -SensorLT.values[:,0:3]

sensorlist = ['SensorLH', 'SensorLT', 'SensorRH', 'SensorRT', 'SensorSN']
gForceList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]

Data = {}
for sensor in sensorlist:
    Data[sensor] = {}
    for g in gForceList:
        print(str(sensor)+' '+ str(g)+' G')
        Data[sensor][g] = cut_milling(vars()[sensor])
        
pickle_out = open("DataMilling1-16g.pickle", "wb")
pickle.dump(Data, pickle_out)
pickle_out.close()
\end{lstlisting}
\clearpage

\subsubsection{Data Comparison}
Comparison between sensor data obtained during the test and simulation data from AMS.

\begin{lstlisting}[language=Python]
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pylab
from anypytools import AnyPyProcess
from anypytools.macro_commands import SetValue, Load, OperationRun, Dump
import os
import time
from scipy import signal
import scipy as sp
import pickle
from matplotlib import style
style.use("seaborn-bright")
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)


### Functions
def PolarFilter(data, fs, order, cutoff):
    """Filters data based on filter settings"""
    w = cutoff / (fs / 2)  # Normalize freq
    b, a = signal.butter(order, w, 'low')
    output = signal.filtfilt(b, a, data, axis=0)
    return output


def PolarFFT(data):
    """
    Performs FFT on data.
    'data' is expected to be DataFrame.
    """
    L = len(data)   
    R = sp.fftpack.rfft(data, axis=0)     
    R = np.abs(R)
    R = R[1:-1]
    ts = 1/fs
    f = sp.fftpack.rfftfreq(L,ts)
    f = f[1:-1]   
    
    if len(data.columns) <= 1:
        outputfft = pd.DataFrame(np.zeros((R.size,2)))
        outputfft[0] = R
        outputfft[1] = f
    else:   
        outputfft = R
        outputfft[:,-1] = f
    
    return outputfft


def polar_ginput(data):
    plt.figure(num=None, figsize=(10, 8), dpi=200, facecolor='w', edgecolor='k' )
    plt.plot(data.values[:,1])
    plt.title("Please select the desired range")
    plt.xlabel("Frame (n)") 
    ginput = plt.ginput(2, timeout=0)
    ginput = pd.DataFrame(ginput)
    plt.close()
    dataWind = data[int(ginput.values[0, 0]):int(ginput.values[1, 0])]
    return dataWind


def bland_altman_plot(data1, data2, *args, **kwargs):
    data1     = np.asarray(data1)
    data2     = np.asarray(data2)
    mean      = np.mean([data1, data2], axis=0)
    diff      = data1 - data2                   # Difference between data1 and data2
    pear      = sp.stats.pearsonr(data1, data2)
    md        = np.mean(diff)                   # Mean of the difference
    sd        = np.std(diff, axis=0)            # Standard deviation of the difference
    print('Mean difference between methods:', md)
    print(pear)

    plt.scatter(mean, diff, *args, **kwargs)
    plt.axhline(md,           color='gray', linestyle='solid')
    plt.axhline(md + 1.96*sd, color='gray', linestyle='dashed')
    plt.axhline(md - 1.96*sd, color='gray', linestyle='dashed') 


def Polar_meanDiff(data1, data2):
    diff = data1.mean


def Rotating_API():
    ### Model Macros
    app = AnyPyProcess(silent=True)
    macro = [
        Load('Rotating_Model_V2.main.any'),
        SetValue('Main.AccStudy.tEnd', tEnd),       # Time!
        OperationRun('Main.AccStudy.Kinematics'),
        Dump('Main.AccStudy.Output.Model.LocalAcc'),
        Dump('Main.AccStudy.Output.Model.Segs.Fitting.AccNode.rDDot'),
        Dump('Main.AccStudy.Output.a_prime'),
        Dump('Main.AccStudy.Output.a'),
        Dump('Main.AccStudy.Output.Abscissa.t'),
        ]    
    results = app.start_macro(macro)
    localAcc = results[0]['Main.AccStudy.Output.Model.LocalAcc']
    rDDot = results[0]['Main.AccStudy.Output.Model.Segs.Fitting.AccNode.rDDot']
    t = results[0]['Main.AccStudy.Output.Abscissa.t']
    a_prime = results[0]['Main.AccStudy.Output.a_prime']
    a = results[0]['Main.AccStudy.Output.a']
    results
    return a_prime, t

### G-force to RPM
def Gforce_RPM(gforce):
    G_cenG = gforce
    G_cenAcc = G_cenG * Gravity
    G_v = np.sqrt(G_cenAcc * r)
    G_omega = G_v / r
    G_rps = G_omega / (360*np.pi/180)
    G_rpm = G_rps * 60
    return G_rpm

### MAIN
# Change settings
newRun = False  # True or False
chooseSensor = 'SensorRH'
gForce = 3

# Fixed settings
totalRounds = 1 # Can only be changed if newRun = True
fs = 416
cutoff = 6
Gravity = 9.81
r = 0.198      # meters (m)


########################################
#
#    Import data from Polar sensor 
#    and filter the results
#
########################################
if newRun == True:
    directory = os.getcwd()
    for root,dirs,files in os.walk(directory):
        for file in files:
           if file.endswith(".pickle"):  
               f = open(file, 'rb')
               data = pickle.load(f) 
               f.close()
    
    # Filter data + FFT (TODO)
    dataFilt = {}
    for sensor in data.keys():
        dataFilt[sensor] = {}
        for gStep in data.get(sensor).keys():
            a = data[sensor][gStep]
            dataFilt[sensor][gStep] = pd.DataFrame(PolarFilter(a, 416, 4, cutoff))

        #fftVar = tempData
        #fftinput = pd.DataFrame(fftVar.values[:,0:4])
        #ffttest = pd.DataFrame(PolarFFT(fftinput))

# Create RPM array
RPM = np.zeros((16,5))
RPM[:,0] = np.arange(1,17)

g = 1
for i in range(16):
    RPM[i,1] = Gforce_RPM(g)
    RPM[i,2] = round(Gforce_RPM(g))
    RPM[i,3] = (RPM[i,2]/60)*360
    RPM[i,4] = RPM[i,0]*Gravity
    g += 1  
RPM = pd.DataFrame(RPM, columns=[
        'G-force',
        'RPM', 
        'Rounded RPM', 
        'Model Velocity', 
        'pkheight'])

########################################
#
#    Prepare parameters and variables 
#    for the anybody model
#
########################################
if newRun == True:
    fst = time.time()        
    dataPolar = {}
    dataAnybody = {}        
    for sensor in data.keys():
        dataAnybody[sensor] = {}
        dataPolar[sensor] = {}
        for gStep in data.get(sensor).keys():  
            st = time.time()
            print('Calculating ' + str(sensor) + ' ' + str(gStep) + 'G...', end =" ")
            # Variables               
            w = RPM.values[gStep-1,3]*np.pi/180          # vinkelhastighed (rad/s)
            V = r*w
            Centrifugal_Acc = (V**2/r)
            
            tempData = dataFilt[sensor][gStep]
            peaks, _ = signal.find_peaks(tempData.values[:,1], height=(RPM.values[gStep-1,4], None))
            tempData = pd.DataFrame(tempData.values[peaks[0]:peaks[totalRounds]])
            dataPolar[sensor][gStep] =  tempData
            
            tEnd = (60/RPM.values[gStep-1,2])*totalRounds
            nSteps = len(tempData) 
            
            # Model Options
            with open('Velocity.any', 'w') as f:
                f.write('DriverVel = {'+str(RPM.values[gStep-1,3])+'*pi/180};') # Set velocity in m/s 
                f.close()
            
            #nSteps = round(tEnd*416)  
            with open('nStep.any', 'w') as f:
                f.write('nStep = '+str(nSteps)+';') 
                f.close()
            
            ##  Model  
            a_prime, t = Rotating_API()
            
            a_prime = pd.DataFrame(-a_prime, columns=["X", "Y", "Z"])
            MeanAnybodyY = int(np.mean(a_prime.values[:,0]))
            dataAnybody[sensor][gStep] = a_prime
            print('...done in time ' + str(round(time.time()-st, 2)) + ' seconds.')
           
    dataDone = {}
    dataDone['Anybody'] = dataAnybody
    dataDone['Polar'] = dataPolar
    data = dataDone
    
    dataOut = open('Data-polar-AB.pickle', 'wb')
    pickle.dump(dataDone, dataOut) 
    dataOut.close()
    print('Full analysis done in time ' + str(round(time.time()-fst, 2)) + ' seconds.')
    
if newRun == False:
    dataIn = open('Data-polar-AB.pickle', 'rb') 
    data = pickle.load(dataIn)
    dataIn.close()    
    
# Mean
dataMeans = {}
for system in data.keys():
    dataMeans[system] = {}
    for sensor in data.get(system).keys():
        dataMeans[system][sensor] = {}
        for gStep in data[system].get(sensor).keys():
            dataMeans[system][sensor][gStep] = pd.DataFrame(
                    data[system][sensor][gStep].mean())

t = np.arange(0,(len(data['Polar'][chooseSensor][gForce])/416),(1/416))
# Resampling
dataResam = {}
for system in data.keys():
    dataResam[system] = {}
    for sensor in data.get(system).keys():
        dataResam[system][sensor] = {}
        for gStep in data[system].get(sensor).keys():
            dataResam[system][sensor][gStep] = pd.DataFrame(
                    signal.resample(data[system][sensor][gStep], len(t)))
        

plt.figure(num=None, figsize=(8, 6), dpi=100, facecolor='w', edgecolor='k' )
plt.plot(t, dataStern[gForce].values[:,1])
plt.plot(t, dataResam['Polar']['SensorRH'][gForce].values[:,1])
plt.plot(t, dataResam['Polar']['SensorRT'][gForce].values[:,1])
plt.plot(t, dataResam['Polar']['SensorLH'][gForce].values[:,1])
plt.plot(t, dataResam['Polar']['SensorLT'][gForce].values[:,1])
plt.plot(t, dataResam['Anybody'][chooseSensor][gForce].values[:,0])
plt.xlabel('Time')
plt.ylabel('Acceleration')
pylab.legend(['SensorSN', 'SensorRH', 'SensorRT', 'SensorLH', 'SensorLT', 'AMS'], loc='center left')
plt.show()
\end{lstlisting}
\clearpage

\subsubsection{Sanity-check}
The sanity-check is used to validate the AMS model and the calculations performed within AMS.

\begin{lstlisting}[language=Python]
## Sanity-check
import numpy as np
import matplotlib.pyplot as plt
from anypytools import AnyPyProcess, macro_commands as mc

G = 16 # Set amount of G

if G == 0.5:
    modVel = 288
    RPM = 48
    spr = 60/RPM
    nSteps = round(spr*1000)*360
elif G == 4:
    modVel = 804
    RPM = 134
    spr = 60/RPM
    nSteps = round(spr*1000)*360
elif G == 8:
    modVel = 1140
    RPM = 190
    spr = 60/RPM
    nSteps = round(spr*1000)*360
elif G == 12:
    modVel = 1398
    RPM = 233
    spr = 60/RPM
    nSteps = round(spr*1000)*360
elif G == 16:
    modVel = 1614
    RPM = 269
    spr = 60/RPM
    nSteps = round(spr*1000)*360

# Modification of AnyBody model corresponding to G force
with open('Velocity.any', 'w') as f:
    f.write('DriverVel = {'+str(modVel)+'*pi/180};') 
    f.close()
     
with open('nStep.any', 'w') as f:
    f.write('nStep = '+str(nSteps)+';')              
    f.close()
 
with open('tEnd.any', 'w') as f:
    f.write('tEnd = '+str(spr)+';')                 
    f.close()

# Run AnyBody model
app = AnyPyProcess(silent=True)
macro = [
    mc.Load('Sanity_check.main.any'),
    mc.OperationRun('Main.AccStudy.Kinematics'),
    mc.Dump('Main.AccStudy.Output.a_prime'),
    ]
results = app.start_macro(macro)
a_prime = results[0]['Main.AccStudy.Output.a_prime']
results

# Variables
r = 0.198                        # [m]
g = -9.81                        # [m/s^2]
w = modVel*np.pi/180             # [rad/s]
V = r*w
Centrifugal_Acc = (V**2/r)

# Test of accelerations at different angles
aprime0 = np.array([-Centrifugal_Acc,0])+np.array([-9.81,0])
aprime90 = np.array([-Centrifugal_Acc,0])+np.array([0,9.81])
aprime180 = np.array([-Centrifugal_Acc,0])+np.array([9.81,0])
aprime270 = np.array([-Centrifugal_Acc,0])+np.array([0,-9.81])

degIdx0 = 0
degIdx90 = round((nSteps*0.25))-1
degIdx180 = round((nSteps*0.5))-1
degIdx270 = round((nSteps*0.75))-1

# Comparison of a' based on AnyBody and calculations
print('Calculation aprime 0 degrees', aprime0)
print('\nAnyBody 0 degrees', a_prime[degIdx0])

print('\nCalculation aprime 90 degrees', aprime90)
print('\nAnyBody 90 degrees', a_prime[degIdx90])

print('\nCalculation aprime 180 degrees', aprime180)
print('\nAnyBody 180 degrees', a_prime[degIdx180])

print('\nCalculation aprime 270 degrees', aprime270)
print('\nAnyBody 270 degrees', a_prime[degIdx270])

plt.figure()
plt.plot(a_prime[:,0])
\end{lstlisting}
\clearpage